package com.example.yenosibi_mybookwishlist;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.os.Bundle;
import android.provider.MediaStore;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.EditText;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.DialogFragment;

/*
 *
 * Class Name: EditorDeleteFragment
 *
 * Description: This class creates a layout for a book to be edited or deleted based on the option selected by the user.
 * It implements a DialogFragment and passes information to the Main Activity on which book has been edited or deleted
 *
 * Design Rationale: The Edit and Delete View is being generated by this class because the Edit View is generated based on the options selected in
 * the Delete View. The class leaves the responsibility of editing or deleting a book to the Main Activity as it creates a loosely coupled system
 *
 * Outstanding Issues: The class does not enforce the user to fill in all of the fields
 */

public class EditDeleteFragment extends DialogFragment {

    interface EditDeleteListener{
        void createEditView() ;
        void delete(int position) ;
        void edit(int position , Book editedBook) ;
    }

    private  EditDeleteListener editDeleteListener ;

    public EditDeleteFragment(){

    }

    public static EditDeleteFragment newInstance(int position , Book book){
        Bundle bookArgs = new Bundle() ;

        bookArgs.putSerializable("Book" , book);
        bookArgs.putInt("BookPosition" , position);

        EditDeleteFragment editDeleteFragment = new EditDeleteFragment() ;
        editDeleteFragment.setArguments(bookArgs);

        return editDeleteFragment ;
    }

    public static EditDeleteFragment newInstance(int position , Book book , boolean editOrDelete){
        Bundle bookArgs = new Bundle() ;

        bookArgs.putSerializable("Book" , book);
        bookArgs.putInt("BookPosition" , position);
        bookArgs.putBoolean("EditOrDelete" , editOrDelete);

        EditDeleteFragment editDeleteFragment = new EditDeleteFragment() ;
        editDeleteFragment.setArguments(bookArgs);

        return editDeleteFragment ;
    }

    @Override
    public void onAttach(@NonNull Context context) {
        super.onAttach(context);
        if (context instanceof EditDeleteListener) {
            editDeleteListener = (EditDeleteListener) context;
        } else {
            throw new RuntimeException(context + " must implement AddCityDialogListener");
        }
    }

    @NonNull
    @Override
    public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) {

        Bundle selectedBookArgs = getArguments() ;
        Book selectedBook = (Book) selectedBookArgs.getSerializable("Book") ;
        int bookPosition = selectedBookArgs.getInt("BookPosition") ;
        Dialog selectDialogBox = (selectedBookArgs.containsKey("EditOrDelete")) ? EditBookCreation(selectedBook , bookPosition) : deleteBookCreation(selectedBook , bookPosition) ;

        return selectDialogBox ;
    }
//Create Edit Dialog Box
    private Dialog EditBookCreation(Book selectedBook , int bookPosition){
        AlertDialog.Builder editBuilder = new AlertDialog.Builder(getContext()) ;
        View editDeleteView = LayoutInflater.from(getContext()).inflate(R.layout.fragment_add_book, null) ;

        EditText editBookName  = editDeleteView.findViewById(R.id.editBookName) ;
        EditText editAuthorName = editDeleteView.findViewById(R.id.editAuthorName) ;
        EditText editGenre = editDeleteView.findViewById(R.id.editGenre) ;
        EditText editPublYear = editDeleteView.findViewById(R.id.editYear) ;
        RadioGroup editStatusGroup = editDeleteView.findViewById(R.id.editStatus) ;

//      Set Listners that handle textViolations
        bookCharacterCount(editBookName);
        authorCharacterCount(editAuthorName);

        editBookName.setText(selectedBook.getBookTitle());
        editAuthorName.setText(selectedBook.getAuthorName());
        editGenre.setText(selectedBook.getGenre());
        editPublYear.setText(String.valueOf(selectedBook.getPublicationYear())) ;
//        editStatus.setText(selectedBook.getStatus());

        for(int i = 0 ; i < editStatusGroup.getChildCount() ; i++){
            RadioButton statusButton = (RadioButton) editStatusGroup.getChildAt(i) ;

            if(statusButton.getText().toString().equals(selectedBook.getStatus())){
                statusButton.setChecked(true);
            }
        }

        Dialog editDialog = editBuilder
                .setView(editDeleteView)
                .setNegativeButton("Cancel" , null)
                .setPositiveButton("Update Book Information" , (dialog , which) -> {
                    String bookName = editBookName.getText().toString() ;
                    String authorName = editAuthorName.getText().toString() ;
                    String genre = editGenre.getText().toString() ;
                    String pubYear = editPublYear.getText().toString() ;
                    int selectedRadioButtonId = editStatusGroup.getCheckedRadioButtonId();
                    RadioButton selectedRadioButton = editDeleteView.findViewById(selectedRadioButtonId);
                    String status = selectedRadioButton.getText().toString();

                    //                      Edit Book In array adapter
                    Book editedBook = new Book(bookName , authorName , genre , pubYear , status) ;
                    editDeleteListener.edit(bookPosition, editedBook);
                }).create() ;

        publicationIntegerCount(editPublYear , (AlertDialog) editDialog);

        return editDialog ;
    }
// Create Delete Dialog Box
    private Dialog deleteBookCreation(Book selectedBook , int bookPosition){
        AlertDialog.Builder editDeleteBuilder = new AlertDialog.Builder(getContext()) ;
        View editDeleteView = LayoutInflater.from(getContext()).inflate(R.layout.fragment_view_delete_book, null) ;

        TextView bookTitleTextView  = editDeleteView.findViewById(R.id.bookTitleView) ;
        TextView authorTextView = editDeleteView.findViewById(R.id.authorNameView) ;
        TextView genreTextView = editDeleteView.findViewById(R.id.genreView) ;
        TextView pubYearView = editDeleteView.findViewById(R.id.publicationYearView) ;
        TextView statusView = editDeleteView.findViewById(R.id.statusView) ;


        bookTitleTextView.setText(selectedBook.getBookTitle());
        authorTextView.setText(selectedBook.getAuthorName());
        genreTextView.setText(selectedBook.getGenre());
        pubYearView.setText(selectedBook.getPublicationYear());
        statusView.setText(selectedBook.getStatus());


        Dialog editDeleteDialog = editDeleteBuilder
                .setView(editDeleteView)
                .setNegativeButton("Remove Book" , (dialog , which) -> {
                    editDeleteListener.delete(bookPosition);
                })
                .setPositiveButton("Edit Book",(dialog , which)->{
                    editDeleteListener.createEditView();
                })
                .setNeutralButton("Cancel" , (dialog , which)->{
                })
                .create() ;
        return editDeleteDialog;
    }

    private void bookCharacterCount(EditText editBookName){
        editBookName.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence charSequence, int start, int before, int count) {
            }

            @Override
            public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
            }

            @Override
            public void afterTextChanged(Editable editable) {
                if(editable.length() == 50){
                    editBookName.setError("Book Limit of 50 words reached");
                }
            }
        });
    }

    private void authorCharacterCount(EditText editAuthorName){
        editAuthorName.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence charSequence, int start, int before, int count) {
            }

            @Override
            public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
            }

            @Override
            public void afterTextChanged(Editable editable) {
                if(editable.length() == 30){
                    editAuthorName.setError("Author Name Limit has been reached");
                }
            }
        });
    }

    private void publicationIntegerCount(EditText editDate , AlertDialog addBookDialog){
        editDate.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence charSequence, int start, int before, int count) {

            }

            @Override
            public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
            }

            @Override
            public void afterTextChanged(Editable editable) {
                if(editable.length() != 4){
                    editDate.setError("Date has to have 4 numbers");
                }
                addBookDialog.getButton(Dialog.BUTTON_POSITIVE).setEnabled(editable.length() == 4);
            }
        });
    }
}
